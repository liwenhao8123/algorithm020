# lwh practice algorithm Week3

## 复习堆的使用
对上周的堆使用和实现复习了一下，根据超提供的堆实现例子，用C语言改造下，后面再刷堆的题可以拿来直接用
这里就体现出高级语言的优势了，像常用的堆基础类库都有实现了，用C的话，需要自己造轮子，不过对二叉堆的实现理解更深入了

## 刷了一遍TopK的题，小小总结下：
1.看了题解通常两种方式来解决：快速排序和利用堆

2.输入数据可修改，并且输入数据量不太大时，快排执行会更快

3.如果不能修改原数据，并且输入数据很大时，用快排需要拷贝一份数据就不太划算，这种用堆处理比较好

## 本周学习了递归，进行遍历二叉树的练习
关于前中后序遍历都用递归写了一遍，整体逻辑都很相似，只需要调整下调用顺序即可
然后尝试使用迭代法（利用栈）进行二叉树的遍历，先进行了前序遍历，逻辑比较清晰简单
然后进行中序遍历时想套用前序代码简单改下，发现模板并不能通用，然后后序遍历倒是可以在前序遍历的基础上调整下入栈顺序，最后的结果再翻转下

前序：中左右

后序：左右中

   调整入栈顺序   翻转结果

中左右-----》中右左-----》左右中

然后看了题解，有人将迭代法的前中后序遍历，写出了统一风格的迭代法，不用在纠结于前序写出来了，中序写不出来的情况了。
通过标记法引入NULL，原因是：中序遍历使用栈的话，无法同时解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情况。
解决办法是：将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。
标记的方法是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。
https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/che-di-chi-tou-er-cha-shu-de-qian-zhong-hou-xu-d-2/
看完有点懵，需要用五毒法了

## 二叉树相关习题总结
1.均使用递归的方式来解决

2.从前序和中序遍历来构建二叉树，关键是先找到本层的根节点，然后分解为构建左子树和右子树的小事件，再逐层递归

3.二叉树的最近公共祖先，分解为当前节点找左子树或右子树是否同时包含了p q，关键点是找到后要把找到的地址逐层的返回

## 关于回溯
全排列的题目搞得有点晕，对于回溯的思想是理解的，看了题解也能明白，但是自己动手写时，不能一次把细节都处理好，再调试时才发现逻辑问题，还是需要多多的练习